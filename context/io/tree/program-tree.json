{
  "name": "conversation-bot",
  "type": "dir",
  "contents": [
    {
      "name": ".gitignore",
      "type": "file",
      "contents": "\"# Node modules\\nnode_modules/\\n\\n# Logs\\nlogs/\\n*.log\\nnpm-debug.log*\\nyarn-debug.log*\\nyarn-error.log*\\n\\n# OS files\\n.DS_Store\\nThumbs.db\\n\\n# Environment files\\n.env\\n.env.*\\ncustom.env\\n# toy front end\\ntoy-front-end/\\n# Build output\\ndist/\\nbuild/\\n\\n# IDE files\\n.vscode/\\n.idea/\\n\\n# Misc\\n*.sublime-workspace\\n*.sublime-project \""
    },
    {
      "name": "README-project-tree.md",
      "type": "md",
      "contents": "\"# Project Tree Builder\\n\\nA TypeScript script that traverses project folders and builds a nested tree JSON representation of the file structure, respecting `.gitignore` patterns.\\n\\n## Features\\n\\n- **Gitignore Support**: Automatically reads and respects `.gitignore` patterns\\n- **Nested Structure**: Creates a hierarchical tree representation of files and directories\\n- **Content Inclusion**: Includes escaped file contents for all readable files\\n- **Type Safety**: Written in TypeScript with proper type definitions\\n- **Cross-Platform**: Works on any Node.js-supported platform\\n\\n## Usage\\n\\n### Prerequisites\\n\\n- Node.js (>= 20.0.0)\\n- TypeScript and ts-node installed\\n\\n### Running the Script\\n\\n1. Navigate to the project directory you want to analyze\\n2. Run the script:\\n\\n```bash\\nnpx ts-node build-project-tree.ts\\n```\\n\\n### Output\\n\\nThe script will:\\n1. Create a `context/out` directory if it doesn't exist\\n2. Generate a JSON file named `{project-name}.json` containing the project tree\\n3. Log progress information to the console\\n\\n## Output Format\\n\\nThe generated JSON has the following structure:\\n\\n```typescript\\ninterface FileNode {\\n  name: string;           // File or directory name\\n  type: 'dir' | string;   // 'dir' for directories, file extension for files\\n  contents: string | FileNode[]; // File content (escaped) or array of child nodes\\n}\\n\\ninterface ProjectTree {\\n  name: string;           // Project name (directory name)\\n  type: 'dir';           // Always 'dir' for root\\n  contents: FileNode[];   // Array of root-level files/directories\\n}\\n```\\n\\n## Example Output\\n\\n```json\\n{\\n  \\\"name\\\": \\\"my-project\\\",\\n  \\\"type\\\": \\\"dir\\\",\\n  \\\"contents\\\": [\\n    {\\n      \\\"name\\\": \\\"src\\\",\\n      \\\"type\\\": \\\"dir\\\",\\n      \\\"contents\\\": [\\n        {\\n          \\\"name\\\": \\\"index.ts\\\",\\n          \\\"type\\\": \\\"ts\\\",\\n          \\\"contents\\\": \\\"\\\\\\\"console.log('Hello World');\\\\\\\\n\\\\\\\"\\\"\\n        }\\n      ]\\n    },\\n    {\\n      \\\"name\\\": \\\"package.json\\\",\\n      \\\"type\\\": \\\"json\\\",\\n      \\\"contents\\\": \\\"\\\\\\\"{\\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"my-project\\\\\\\\\\\\\\\"}\\\\\\\"\\\"\\n    }\\n  ]\\n}\\n```\\n\\n## Files Ignored\\n\\nThe script automatically ignores files and directories specified in `.gitignore`, including:\\n- `node_modules/`\\n- `dist/` and `build/`\\n- `.DS_Store` and other OS files\\n- IDE files (`.vscode/`, `.idea/`)\\n- Log files\\n- Environment files (`.env`)\\n\\n## Customization\\n\\nYou can modify the script to:\\n- Change the output directory by modifying the `outputDir` parameter in `saveTree()`\\n- Add additional ignore patterns\\n- Modify the file content handling logic\\n- Add filtering for specific file types\\n\\n## Dependencies\\n\\n- `ignore`: For parsing `.gitignore` patterns\\n- `@types/node`: TypeScript definitions for Node.js\\n- Built-in Node.js modules: `fs`, `path` \""
    },
    {
      "name": "README.md",
      "type": "md",
      "contents": "\"# conversation-bot\\nA conversation bot application with Twilio integration and HTTP support\\n\""
    },
    {
      "name": "conversation-state.json",
      "type": "json",
      "contents": "\"{\\n  \\\"currentIndex\\\": 1,\\n  \\\"lastMessageTime\\\": \\\"2025-07-30T15:17:42.302Z\\\",\\n  \\\"isActive\\\": false,\\n  \\\"messageCount\\\": 1\\n}\""
    },
    {
      "name": "package.json",
      "type": "json",
      "contents": "\"{\\n  \\\"engines\\\": {\\n    \\\"node\\\": \\\">=20.0.0\\\"\\n  },\\n  \\\"dependencies\\\": {\\n    \\\"@types/node\\\": \\\"^24.2.1\\\",\\n    \\\"@zohocrm/typescript-sdk-2.1\\\": \\\"^1.1.0\\\",\\n    \\\"@zohocrm/typescript-sdk-8.0\\\": \\\"^2.0.0\\\",\\n    \\\"cors\\\": \\\"^2.8.5\\\",\\n    \\\"dotenv\\\": \\\"^17.2.0\\\",\\n    \\\"express\\\": \\\"^4.18.2\\\",\\n    \\\"form-data\\\": \\\"^4.0.3\\\",\\n    \\\"got\\\": \\\"^14.4.7\\\",\\n    \\\"ignore\\\": \\\"^7.0.5\\\",\\n    \\\"moment-timezone\\\": \\\"^0.6.0\\\",\\n    \\\"morgan\\\": \\\"^1.10.0\\\",\\n    \\\"ts-node\\\": \\\"^10.9.2\\\",\\n    \\\"twilio\\\": \\\"^5.8.0\\\",\\n    \\\"typescript\\\": \\\"^5.8.3\\\",\\n    \\\"winston\\\": \\\"^3.17.0\\\",\\n    \\\"ws\\\": \\\"^8.18.3\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"npx ts-node -r ./tsconfig-paths-bootstrap.js src/server.ts\\\",\\n    \\\"build\\\": \\\"tsc\\\",\\n    \\\"dev\\\": \\\"npx ts-node -r ./tsconfig-paths-bootstrap.js src/server.ts\\\"\\n  },\\n  \\\"devDependencies\\\": {\\n    \\\"@types/cors\\\": \\\"^2.8.17\\\",\\n    \\\"@types/express\\\": \\\"^5.0.3\\\",\\n    \\\"@types/morgan\\\": \\\"^1.9.9\\\",\\n    \\\"@types/ws\\\": \\\"^8.18.1\\\",\\n    \\\"tsconfig-paths\\\": \\\"^4.2.0\\\"\\n  }\\n}\\n\""
    },
    {
      "name": "src",
      "type": "dir",
      "contents": [
        {
          "name": "app.ts",
          "type": "ts",
          "contents": "\"import express, { Request, Response, NextFunction } from 'express';\\nimport cors from 'cors';\\nimport morgan from 'morgan';\\nimport routes from './routes';\\n\\nconst app = express();\\n\\n// Middleware\\napp.use(express.json());\\napp.use(express.urlencoded({ extended: true }));\\n\\n// CORS middleware\\napp.use(cors());\\n\\n// Custom request logging middleware - logs ALL requests\\napp.use((req: Request, res: Response, next: NextFunction) => {\\n  const timestamp = new Date().toISOString();\\n  const port = process.env.PORT || 3000;\\n  const fullUrl = `${req.protocol}://${req.get('host')}${req.originalUrl}`;\\n  \\n  console.log(`\\\\n🚀 [${timestamp}] REQUEST RECEIVED:`);\\n  console.log(`📍 Port: ${port}`);\\n  console.log(`🌐 URL: ${fullUrl}`);\\n  console.log(`📝 Method: ${req.method}`);\\n  console.log(`🔗 Path: ${req.path}`);\\n  console.log(`📊 Query:`, req.query);\\n  console.log(`📋 Headers:`, req.headers);\\n  console.log(`📦 Body:`, req.body);\\n  console.log(`👤 IP: ${req.ip || req.connection.remoteAddress}`);\\n  console.log(`🔍 User Agent: ${req.get('User-Agent')}`);\\n  console.log(`─`.repeat(80));\\n  \\n  next();\\n});\\n\\n// Morgan logging middleware (development only)\\nif (process.env.NODE_ENV === 'development') {\\n  app.use(morgan('dev'));\\n}\\n\\n// Production-only middleware\\nif (process.env.NODE_ENV === 'production') {\\n  // Add production-specific middleware here if needed\\n  // Example: helmet, compression, rate limiting\\n}\\n\\n// Mount all routes under /api\\napp.use('/api', routes);\\n\\n// 404 handler\\napp.use('*', (req: Request, res: Response) => {\\n  res.status(404).json({\\n    error: 'Not Found',\\n    message: 'The requested resource was not found'\\n  });\\n});\\n\\n// Global error handler\\napp.use((err: Error, req: Request, res: Response, next: NextFunction) => {\\n  console.error('Global error handler:', err);\\n  \\n  res.status(500).json({\\n    error: 'Internal Server Error',\\n    message: 'Something went wrong on the server'\\n  });\\n});\\n\\nexport default app; \""
        },
        {
          "name": "controllers",
          "type": "dir",
          "contents": [
            {
              "name": "conversation.controller.ts",
              "type": "ts",
              "contents": "\"import { handleConversationWithReset, handleConversationMessage as handleConversationMessageService } from '@services/conversation/conversationHandler';\\nimport { Request, Response } from 'express';\\n\\n// Twilio message handler\\nexport async function handleTwilioMessage(message: string): Promise<void> {\\n  // Parse commands at the controller level\\n  const shouldReset = message.toLowerCase().includes('reset');\\n  const shouldInit = message.toLowerCase().includes('init');\\n  \\n  console.log('[ConversationController] Processing Twilio message:', {\\n    message,\\n    shouldReset,\\n    shouldInit\\n  });\\n  \\n  // Handle reset + init combination\\n  if (shouldReset && shouldInit) {\\n    console.log('[ConversationController] Reset + Init command detected');\\n    await handleConversationWithReset(true, true);\\n  }\\n  // Handle reset only\\n  else if (shouldReset) {\\n    console.log('[ConversationController] Reset command detected');\\n    await handleConversationWithReset(true, false);\\n  }\\n  // Handle init only\\n  else if (shouldInit) {\\n    console.log('[ConversationController] Init command detected');\\n    await handleConversationWithReset(false, true);\\n  }\\n  // Normal conversation flow\\n  else {\\n    console.log('[ConversationController] Normal conversation flow');\\n    await handleConversationWithReset(false, false);\\n  }\\n}\\n\\n// HTTP conversation message handler\\nexport async function handleConversationMessage(req: Request, res: Response): Promise<void> {\\n  const { Body } = req.body;\\n\\n  if (!Body || typeof Body !== 'string') {\\n    res.status(400).json({ error: 'Invalid or missing Body field' });\\n    return;\\n  }\\n\\n  console.log('[ConversationController] Received webhook:', Body);\\n  \\n  try {\\n    // Parse commands at the controller level\\n    const shouldReset = Body.toLowerCase().includes('reset');\\n    const shouldInit = Body.toLowerCase().includes('init');\\n    \\n    let result: {\\n      success: boolean;\\n      message?: string;\\n      currentIndex?: number;\\n      totalMessages?: number;\\n      error?: string;\\n    };\\n    \\n    // Handle reset + init combination\\n    if (shouldReset && shouldInit) {\\n      console.log('[ConversationController] Reset + Init command detected');\\n      result = await handleConversationWithReset(true, true);\\n    }\\n    // Handle reset only\\n    else if (shouldReset) {\\n      console.log('[ConversationController] Reset command detected');\\n      result = await handleConversationWithReset(true, false);\\n    }\\n    // Handle init only\\n    else if (shouldInit) {\\n      console.log('[ConversationController] Init command detected');\\n      result = await handleConversationWithReset(false, true);\\n    }\\n    // Normal conversation flow\\n    else {\\n      console.log('[ConversationController] Normal conversation flow');\\n      result = await handleConversationMessageService(Body);\\n    }\\n    \\n    if (result.success) {\\n      console.log('[ConversationController] Conversation message processed successfully:', result);\\n      res.status(200).json({ \\n        status: 'Message received and processed',\\n        conversation: result\\n      });\\n    } else {\\n      console.error('[ConversationController] Conversation message processing failed:', result.error);\\n      res.status(500).json({ \\n        error: 'Failed to process message',\\n        details: result.error\\n      });\\n    }\\n    \\n  } catch (err) {\\n    console.error('[ConversationController] Error handling conversation message:', err);\\n    res.status(500).json({ error: 'Failed to process message' });\\n  }\\n}\\n\\n// Twilio status callback handler\\nexport async function handleTwilioStatusCallback(req: Request, res: Response): Promise<void> {\\n  console.log('[ConversationController] 📞 Received Twilio status callback:', {\\n    MessageSid: req.body.MessageSid,\\n    MessageStatus: req.body.MessageStatus,\\n    To: req.body.To,\\n    From: req.body.From,\\n    ErrorCode: req.body.ErrorCode,\\n    ErrorMessage: req.body.ErrorMessage,\\n    Timestamp: new Date().toISOString()\\n  });\\n\\n  // Log the full callback payload for debugging\\n  console.log('[ConversationController] 📋 Full callback payload:', req.body);\\n\\n  // Handle different status types\\n  switch (req.body.MessageStatus) {\\n    case 'delivered':\\n      console.log('✅ Message delivered successfully!');\\n      break;\\n    case 'undelivered':\\n      console.error('❌ Message undelivered!', {\\n        ErrorCode: req.body.ErrorCode,\\n        ErrorMessage: req.body.ErrorMessage\\n      });\\n      break;\\n    case 'failed':\\n      console.error('💥 Message failed!', {\\n        ErrorCode: req.body.ErrorCode,\\n        ErrorMessage: req.body.ErrorMessage\\n      });\\n      break;\\n    case 'sent':\\n      console.log('📤 Message sent to carrier');\\n      break;\\n    case 'queued':\\n      console.log('⏳ Message queued for delivery');\\n      break;\\n    default:\\n      console.log(`ℹ️ Message status: ${req.body.MessageStatus}`);\\n  }\\n\\n  // Always respond with 200 to acknowledge receipt\\n  res.status(200).send('OK');\\n}\\n\""
            },
            {
              "name": "demo.controller.ts",
              "type": "ts",
              "contents": "\"import { handleConversationMessage, handleConversationWithReset, getConversationStatus, resetConversation } from '@services/conversation/conversationHandler';\\nimport { Request, Response } from 'express';\\n\\nexport async function handleDemoMessage(req: Request, res: Response): Promise<void> {\\n  const { message } = req.body;\\n\\n  if (!message || typeof message !== 'string') {\\n    res.status(400).json({ error: 'Invalid or missing message field' });\\n    return;\\n  }\\n\\n  try {\\n    console.log('[DemoController] Processing message:', message);\\n    \\n    // Parse commands at the controller level - must be ALL CAPS\\n    const shouldReset = message.includes('RESET');\\n    const shouldInit = message.includes('INIT');\\n    const shouldStatus = message.toLowerCase().includes('status');\\n    \\n    // Handle status request\\n    if (shouldStatus) {\\n      console.log('[DemoController] Status request detected');\\n      const status = getConversationStatus();\\n      res.status(200).json({ \\n        status: 'Status retrieved', \\n        conversation: status \\n      });\\n      return;\\n    }\\n    \\n    // Demo ONLY accepts reset + init combination\\n    if (shouldReset && shouldInit) {\\n      console.log('[DemoController] Reset + Init command detected - proceeding with demo');\\n      const result = await handleConversationWithReset(true, true);\\n      \\n      if (result.success) {\\n        res.status(200).json({ \\n          status: 'Demo initiated successfully', \\n          conversation: result \\n        });\\n      } else {\\n        res.status(500).json({ \\n          error: 'Failed to initiate demo', \\n          details: result.error \\n        });\\n      }\\n    } else {\\n      // Demo requires both reset and init - return error if missing either\\n      console.log('[DemoController] Invalid demo command - missing RESET or INIT');\\n      res.status(400).json({ \\n        error: 'Demo requires both \\\"RESET\\\" and \\\"INIT\\\" commands in the message (all caps)',\\n        received: {\\n          hasReset: shouldReset,\\n          hasInit: shouldInit\\n        }\\n      });\\n    }\\n  } catch (err) {\\n    console.error('[DemoController] Error handling message:', err);\\n    res.status(500).json({ error: 'Failed to process message' });\\n  }\\n}\\n\\nexport async function getDemoStatus(req: Request, res: Response): Promise<void> {\\n  try {\\n    const status = getConversationStatus();\\n    res.status(200).json({ \\n      status: 'Status retrieved', \\n      conversation: status \\n    });\\n  } catch (err) {\\n    console.error('[DemoController] Error getting status:', err);\\n    res.status(500).json({ error: 'Failed to get conversation status' });\\n  }\\n}\\n\\nexport async function resetDemoConversation(req: Request, res: Response): Promise<void> {\\n  try {\\n    const result = resetConversation();\\n    res.status(200).json({ \\n      status: 'Conversation reset', \\n      conversation: result \\n    });\\n  } catch (err) {\\n    console.error('[DemoController] Error resetting conversation:', err);\\n    res.status(500).json({ error: 'Failed to reset conversation' });\\n  }\\n} \""
            },
            {
              "name": "index.ts",
              "type": "ts",
              "contents": "\"// Demo controllers\\nexport * from './demo.controller';\\n\\n// Conversation controllers  \\nexport * from './conversation.controller'; \""
            }
          ]
        },
        {
          "name": "models",
          "type": "dir",
          "contents": [
            {
              "name": "conversation",
              "type": "dir",
              "contents": [
                {
                  "name": "conversation.model.ts",
                  "type": "ts",
                  "contents": "\"// Message type enum for different communication channels\\nexport type MessageType = 'text' | 'email' | 'phone call';\\n\\n// Message object structure for records\\nexport interface RecordMessage {\\n    type: MessageType | null;\\n    ai_agent: boolean | null;\\n    content: string;\\n    target_number?: string; // Optional target phone number from JSON\\n}\\n\\n// Configuration object with target number and other key-value pairs\\nexport interface ResolveStreamConfig {\\n    'target-number': string;\\n    [key: string]: any; // Allow for other key-value pairs\\n}\\n\\nexport interface SystemMessage {\\n    \\\"5min\\\": string;\\n    \\\"reset\\\": string;\\n  }\\n  \\n  export interface ConversationState {\\n    i: number;\\n    timer: NodeJS.Timeout | null;\\n    elapsedMinutes: number;\\n  }\\n  \""
                }
              ]
            },
            {
              "name": "twilio",
              "type": "dir",
              "contents": [
                {
                  "name": "twilio.model.ts",
                  "type": "ts",
                  "contents": "\"// Twilio SMS Configuration Types\\nexport interface TwilioConfig {\\n  accountSid: string;\\n  authToken: string;\\n  botNumber: string;\\n}\\n\\n// SMS Message Parameters - Required fields for sending SMS\\nexport interface SMSMessageParams {\\n  to: string;           // Recipient phone number (E.164 format recommended: +1234567890)\\n  from: string;         // Sender phone number (your BOT_NUMBER)\\n  body: string;         // Message content (up to 1600 characters)\\n  statusCallback?: string; // Webhook URL for delivery status updates\\n}\\n\\n// Optional SMS Parameters for enhanced functionality\\nexport interface SMSMessageOptions extends SMSMessageParams {\\n  mediaUrl?: string[];  // Array of media URLs for MMS\\n  statusCallback?: string; // Webhook URL for delivery status updates\\n  maxPrice?: string;    // Maximum price willing to pay for message\\n  provideFeedback?: boolean; // Request delivery feedback\\n  attemptWhitelistRemoval?: boolean; // Attempt to remove from carrier whitelist\\n  validityPeriod?: number; // Message validity period in seconds (max 14400 = 4 hours)\\n  forceDelivery?: boolean; // Force delivery even if recipient opted out\\n  smartEncoded?: boolean; // Enable smart encoding for international messages\\n  persistentAction?: string[]; // Actions to persist across message lifecycle\\n}\\n\\n// Twilio API Response Types\\nexport interface TwilioMessageResponse {\\n  sid: string;          // Unique message identifier\\n  accountSid: string;   // Account SID that created the message\\n  from: string;         // Sender phone number\\n  to: string;           // Recipient phone number  \\n  body: string;         // Message content\\n  status: TwilioMessageStatus; // Current message status\\n  direction: 'inbound' | 'outbound-api' | 'outbound-call' | 'outbound-reply';\\n  apiVersion: string;   // Twilio API version used\\n  price: string | null; // Cost of the message\\n  priceUnit: string;    // Currency of the price\\n  errorCode: number | null; // Error code if message failed\\n  errorMessage: string | null; // Error description if message failed\\n  uri: string;          // URI of the message resource\\n  dateCreated: string;  // ISO 8601 timestamp when message was created\\n  dateSent: string | null; // ISO 8601 timestamp when message was sent\\n  dateUpdated: string;  // ISO 8601 timestamp when message was last updated\\n  messagingServiceSid: string | null; // Messaging service SID if used\\n  numSegments: string;  // Number of segments the message was split into\\n  numMedia: string;     // Number of media files attached\\n  subresourceUris: {    // URIs for related resources\\n    media: string;\\n    feedback: string;\\n  };\\n}\\n\\n// Twilio Message Status Enum\\nexport type TwilioMessageStatus = \\n  | 'accepted'      // Message accepted by Twilio\\n  | 'queued'        // Message queued for delivery\\n  | 'sending'       // Message is being sent\\n  | 'sent'          // Message sent to carrier\\n  | 'receiving'     // Message is being received\\n  | 'received'      // Message received by recipient\\n  | 'delivered'     // Message delivered to recipient\\n  | 'undelivered'   // Message could not be delivered\\n  | 'failed'        // Message failed to send\\n  | 'read';         // Message read by recipient (if supported)\\n\\n// Error Response Type\\nexport interface TwilioError {\\n  code: number;\\n  message: string;\\n  moreInfo: string;\\n  status: number;\\n  details?: Record<string, any>;\\n}\\n\\n// Service Response Type - for handling both success and error cases\\nexport interface TwilioServiceResponse<T = TwilioMessageResponse> {\\n  success: boolean;\\n  data?: T;\\n  error?: TwilioError;\\n}\\n\\n// CRM Integration Types - for connecting with your lead system\\nexport interface CRMNotificationParams {\\n  leadId: string;       // Lead identifier from your CRM\\n  phoneNumber: string;  // Lead's phone number\\n  messageTemplate: string; // Message template/content\\n  personalizedData?: Record<string, string>; // Data for message personalization\\n  priority?: 'low' | 'medium' | 'high' | 'urgent'; // Message priority\\n  scheduledTime?: Date; // Optional: schedule message for later\\n  campaignId?: string;  // Optional: campaign identifier\\n  tags?: string[];      // Optional: message tags for tracking\\n}\\n\\n// Webhook Event Types (if you plan to handle delivery status)\\nexport interface TwilioWebhookEvent {\\n  MessageSid: string;\\n  MessageStatus: TwilioMessageStatus;\\n  To: string;\\n  From: string;\\n  Body: string;\\n  AccountSid: string;\\n  ApiVersion: string;\\n  ErrorCode?: string;\\n  ErrorMessage?: string;\\n}\\n\""
                }
              ]
            }
          ]
        },
        {
          "name": "repositories",
          "type": "dir",
          "contents": [
            {
              "name": "conversation",
              "type": "dir",
              "contents": [
                {
                  "name": "conversation.repo.ts",
                  "type": "ts",
                  "contents": "\"import path from 'path';\\nimport { loadJson } from '@/utilities/fileLoader';\\nimport { SystemMessage } from '@models/conversation/conversation.model';\\n\\nexport function getConversationScript(): string[] {\\n  const filePath = path.resolve(__dirname, 'data', 'carl_contact.json');\\n  return loadJson<string[]>(filePath);\\n}\\n\\nexport function getSystemMessages(): SystemMessage {\\n  const filePath = path.resolve(__dirname, 'data', 'systemMessages.json');\\n  return loadJson<SystemMessage>(filePath);\\n}\\n\""
                },
                {
                  "name": "data",
                  "type": "dir",
                  "contents": [
                    {
                      "name": "carl_contact.json",
                      "type": "json",
                      "contents": "\"[\\n    \\\"Hey, this is John from ABC Automotive. Is this Evan?\\\",\\n    \\\"We spoke a while back—it wasn’t the right fit then. We’ve got some customers looking for specific vehicles now, so we’re reaching out to folks who might be open to selling theirs—contingent, of course, on us offering an amazing price.\\\",\\n    \\\"I get it—it probably sounds weird getting a text saying we want to overpay for your car, no strings attached. The “catch” is I’d need to see the vehicle.\\\",\\n    \\\"Totally get it. The hardest part of my job is throwing out a number without seeing the car. If I aim high and it needs work, you’ll feel like I wasted your time. If I go low just to play it safe, it might not sound appealing—even if it is.\\\",\\n    \\\"Fair enough. If we could pay you even more by deeply discounting one of our current vehicles as part of a trade, would you at least be open to hearing what that could look like?\\\",\\n    \\\"We’re trying to cycle inventory to meet demand. There’s a lot of interest in your vehicle right now, and less in some of our other models—even ones that would be an upgrade for you. By making it worth your while, we meet our customers’ needs and earn your business.\\\",\\n    \\\"Totally fair. Bring her with you when you come in to check things out.\\\",\\n    \\\"Would today at 3 PM work for both of you?\\\",\\n    \\\"Totally understand. We don’t want to waste our time either—if we bring someone in without a real shot at doing a deal, that’s time we can’t get back. We’re fully aligned in wanting this to be worth it.\\\",\\n    \\\"Since today doesn’t work, how about tomorrow at 6 PM?\\\",\\n    \\\"Perfect. I’ll text you our address now to confirm. Looking forward to seeing you both.\\\",\\n    \\\"See you then!\\\"\\n]\\n\""
                    },
                    {
                      "name": "systemMessages.json",
                      "type": "json",
                      "contents": "\"{\\n    \\\"5min\\\": \\\"Demo Reset - 5 mins\\\",\\n    \\\"reset\\\": \\\"Demo Reset. Reply to begin\\\"\\n}\""
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "routes",
          "type": "dir",
          "contents": [
            {
              "name": "conversation.routes.ts",
              "type": "ts",
              "contents": "\"import express from 'express';\\nimport { \\n  handleConversationMessage, \\n  handleTwilioStatusCallback \\n} from '@controllers/index';\\n\\nconst router = express.Router();\\n\\n// POST /api/conversation/ - Handle conversation messages\\nrouter.post('/', handleConversationMessage);\\n\\n// POST /api/conversation/twilio/status - Twilio status callback\\nrouter.post('/twilio/status', handleTwilioStatusCallback);\\n\\nexport default router;\\n\""
            },
            {
              "name": "demo.routes.ts",
              "type": "ts",
              "contents": "\"import express from 'express';\\nimport { handleDemoMessage, getDemoStatus } from '@controllers/index';\\n\\nconst router = express.Router();\\n\\n// POST /api/demo/ - Handle conversation messages (requires both RESET and INIT)\\nrouter.post('/', handleDemoMessage);\\n\\n// GET /api/demo/status - Get conversation status\\nrouter.get('/status', getDemoStatus);\\n\\nexport default router;\""
            },
            {
              "name": "index.ts",
              "type": "ts",
              "contents": "\"import { Router } from 'express';\\nimport conversationRoutes from './conversation.routes';\\nimport demoRoutes from './demo.routes';\\n\\nconst router = Router();\\n\\n// Mount all routes\\nrouter.use('/conversation', conversationRoutes);\\nrouter.use('/demo', demoRoutes);\\n\\nexport default router; \""
            }
          ]
        },
        {
          "name": "server.ts",
          "type": "ts",
          "contents": "\"import app from './app';\\n\\nconst PORT = process.env.PORT || 3000;\\n\\napp.listen(PORT, () => {\\n  console.log(`\\\\n🎯 SERVER STARTED:`);\\n  console.log(`📍 Port: ${PORT}`);\\n  console.log(`🌍 Environment: ${process.env.NODE_ENV || 'development'}`);\\n  console.log(`🚀 Server URL: http://localhost:${PORT}`);\\n  console.log(`📡 API Base URL: http://localhost:${PORT}/api`);\\n  console.log(`📊 Request logging: ENABLED`);\\n  console.log(`─`.repeat(80));\\n  console.log(`✅ Server is ready to receive requests!\\\\n`);\\n}); \""
        },
        {
          "name": "services",
          "type": "dir",
          "contents": [
            {
              "name": "conversation",
              "type": "dir",
              "contents": [
                {
                  "name": "conversationHandler.ts",
                  "type": "ts",
                  "contents": "\"import { getConversationScript } from '@repositories/conversation/conversation.repo';\\nimport { sendText } from '@utilities/twilio';\\nimport { stateManager } from './stateManager';\\nimport { startTimer } from './conversationRuntime';\\nimport { config } from 'dotenv';\\n\\nconfig({ path: '.env.local' });\\n\\nconst TARGET_NUMBER = process.env.TARGET_NUMBER!;\\nif (!TARGET_NUMBER) {\\n  throw new Error('TARGET_NUMBER is not defined in .env');\\n}\\n\\nconst convoReply = getConversationScript();\\n\\nexport async function handleConversationMessage(message: string): Promise<{\\n  success: boolean;\\n  message?: string;\\n  currentIndex?: number;\\n  totalMessages?: number;\\n  error?: string;\\n}> {\\n  try {\\n    console.log('[ConversationHandler] Processing message:', message);\\n    \\n    // Get current state\\n    const currentIndex = stateManager.getCurrentIndex();\\n    console.log(`[ConversationHandler] Current index: ${currentIndex}/${convoReply.length}`);\\n\\n    // Check if we've reached the end\\n    if (currentIndex >= convoReply.length) {\\n      console.warn('[ConversationHandler] No more replies to send');\\n      return {\\n        success: true,\\n        message: 'Conversation complete - no more messages to send',\\n        currentIndex,\\n        totalMessages: convoReply.length\\n      };\\n    }\\n\\n    // Get the message to send\\n    const messageToSend = convoReply[currentIndex];\\n    console.log(`[ConversationHandler] Sending message ${currentIndex + 1}/${convoReply.length}: \\\"${messageToSend}\\\"`);\\n    \\n    // Send the message\\n    const twilioResponse = await sendText(TARGET_NUMBER, messageToSend);\\n    \\n    if (twilioResponse.success) {\\n      console.log('[ConversationHandler] ✅ Message sent successfully:', {\\n        sid: twilioResponse.data?.sid,\\n        status: twilioResponse.data?.status,\\n        to: twilioResponse.data?.to,\\n        dateCreated: twilioResponse.data?.dateCreated\\n      });\\n      \\n      // Increment the index for next time\\n      stateManager.incrementIndex();\\n      \\n      return {\\n        success: true,\\n        message: 'Message sent successfully',\\n        currentIndex: currentIndex + 1,\\n        totalMessages: convoReply.length\\n      };\\n    } else {\\n      console.error('[ConversationHandler] ❌ Message failed to send:', {\\n        errorCode: twilioResponse.error?.code,\\n        errorMessage: twilioResponse.error?.message,\\n        status: twilioResponse.error?.status,\\n        moreInfo: twilioResponse.error?.moreInfo\\n      });\\n      \\n      return {\\n        success: false,\\n        error: `Failed to send message: ${twilioResponse.error?.message || 'Unknown error'}`,\\n        currentIndex,\\n        totalMessages: convoReply.length\\n      };\\n    }\\n    \\n  } catch (error) {\\n    console.error('[ConversationHandler] Error processing conversation:', error);\\n    return {\\n      success: false,\\n      error: error instanceof Error ? error.message : 'Unknown error occurred'\\n    };\\n  }\\n}\\n\\nexport async function handleConversationWithReset(reset: boolean, init: boolean = false): Promise<{\\n  success: boolean;\\n  message?: string;\\n  currentIndex?: number;\\n  totalMessages?: number;\\n  error?: string;\\n}> {\\n  try {\\n    console.log('[ConversationHandler] Processing with reset/init:', { reset, init });\\n    \\n    // Handle reset\\n    if (reset) {\\n      console.log('[ConversationHandler] Resetting conversation state');\\n      stateManager.resetState();\\n    }\\n    \\n    // Handle init - send first message and start timer\\n    if (init) {\\n      console.log('[ConversationHandler] Initializing conversation');\\n      const firstMessage = convoReply[0];\\n      console.log(`[ConversationHandler] Sending first message: \\\"${firstMessage}\\\"`);\\n      \\n      const twilioResponse = await sendText(TARGET_NUMBER, firstMessage);\\n      \\n      if (twilioResponse.success) {\\n        console.log('[ConversationHandler] ✅ First message sent successfully');\\n        stateManager.incrementIndex();\\n        startTimer();\\n        \\n        return {\\n          success: true,\\n          message: 'Conversation initialized with first message',\\n          currentIndex: 1,\\n          totalMessages: convoReply.length\\n        };\\n      } else {\\n        console.error('[ConversationHandler] ❌ First message failed to send');\\n        return {\\n          success: false,\\n          error: `Failed to send first message: ${twilioResponse.error?.message || 'Unknown error'}`,\\n          currentIndex: 0,\\n          totalMessages: convoReply.length\\n        };\\n      }\\n    }\\n    \\n    // If reset=true and init=false, just return success without sending message\\n    if (reset && !init) {\\n      console.log('[ConversationHandler] Reset only - no message sent');\\n      return {\\n        success: true,\\n        message: 'Conversation state reset',\\n        currentIndex: 0,\\n        totalMessages: convoReply.length\\n      };\\n    }\\n    \\n    // Normal conversation flow (only if reset=false and init=false)\\n    return await handleConversationMessage('');\\n    \\n  } catch (error) {\\n    console.error('[ConversationHandler] Error processing conversation with reset/init:', error);\\n    return {\\n      success: false,\\n      error: error instanceof Error ? error.message : 'Unknown error occurred'\\n    };\\n  }\\n}\\n\\nexport function getConversationStatus() {\\n  return {\\n    currentIndex: stateManager.getCurrentIndex(),\\n    totalMessages: convoReply.length,\\n    messageCount: stateManager.getMessageCount(),\\n    lastMessageTime: stateManager.getLastMessageTime(),\\n    isActive: stateManager.isActive()\\n  };\\n}\\n\\nexport function resetConversation() {\\n  stateManager.resetState();\\n  return {\\n    success: true,\\n    message: 'Conversation reset successfully',\\n    currentIndex: 0,\\n    totalMessages: convoReply.length\\n  };\\n} \""
                },
                {
                  "name": "conversationRuntime.ts",
                  "type": "ts",
                  "contents": "\"import { ConversationState, SystemMessage } from '@models/conversation/conversation.model';\\nimport { getSystemMessages } from '@repositories/conversation/conversation.repo';\\nimport { sendText } from '@utilities/twilio';\\nimport { config } from 'dotenv';\\nconfig({ path: '.env.local' });\\n\\n// Load target phone number from .env\\nconst TARGET_NUMBER = process.env.TARGET_NUMBER!;\\nif (!TARGET_NUMBER) {\\n  throw new Error('TARGET_NUMBER is not defined in custom.env');\\n}\\n\\nconst state: ConversationState = {\\n  i: 0,\\n  timer: null,\\n  elapsedMinutes: 0,\\n};\\n\\nexport function getIndex() {\\n  return state.i;\\n}\\n\\nexport function setIndex(value: number) {\\n  state.i = value;\\n}\\n\\nexport function incrementIndex() {\\n  state.i += 1;\\n}\\n\\nexport function stopTimer() {\\n  if (state.timer) {\\n    clearInterval(state.timer);\\n    state.timer = null;\\n  }\\n}\\n\\nexport function startTimer() {\\n  stopTimer(); // Safety reset\\n  state.elapsedMinutes = 0;\\n  const systemMessages: SystemMessage = getSystemMessages();\\n\\n  state.timer = setInterval(() => {\\n    state.elapsedMinutes++;\\n\\n    if (state.elapsedMinutes === 25) {\\n      sendText(TARGET_NUMBER, systemMessages[\\\"5min\\\"]);\\n    }\\n\\n    if (state.elapsedMinutes === 30) {\\n      sendText(TARGET_NUMBER, systemMessages[\\\"reset\\\"]);\\n      setIndex(0);\\n      stopTimer();\\n    }\\n  }, 60 * 1000); // Every minute\\n}\\n\\n// Export a function to check if timer is active\\nexport function isTimerActive(): boolean {\\n  return state.timer !== null;\\n}\\n\""
                },
                {
                  "name": "index.ts",
                  "type": "ts",
                  "contents": "\"export * from './conversationHandler';\\nexport * from './conversationRuntime';\\nexport * from './stateManager';\\n\""
                },
                {
                  "name": "stateManager.ts",
                  "type": "ts",
                  "contents": "\"import fs from 'fs';\\nimport path from 'path';\\n\\ninterface ConversationState {\\n  currentIndex: number;\\n  lastMessageTime: string;\\n  isActive: boolean;\\n  messageCount: number;\\n}\\n\\nconst STATE_FILE_PATH = path.join(process.cwd(), 'conversation-state.json');\\n\\n// Default state\\nconst DEFAULT_STATE: ConversationState = {\\n  currentIndex: 0,\\n  lastMessageTime: new Date().toISOString(),\\n  isActive: false,\\n  messageCount: 0\\n};\\n\\nclass StateManager {\\n  private state: ConversationState;\\n\\n  constructor() {\\n    this.state = this.loadState();\\n  }\\n\\n  private loadState(): ConversationState {\\n    try {\\n      if (fs.existsSync(STATE_FILE_PATH)) {\\n        const data = fs.readFileSync(STATE_FILE_PATH, 'utf8');\\n        return { ...DEFAULT_STATE, ...JSON.parse(data) };\\n      }\\n    } catch (error) {\\n      console.error('[StateManager] Error loading state:', error);\\n    }\\n    return { ...DEFAULT_STATE };\\n  }\\n\\n  private saveState(): void {\\n    try {\\n      fs.writeFileSync(STATE_FILE_PATH, JSON.stringify(this.state, null, 2));\\n    } catch (error) {\\n      console.error('[StateManager] Error saving state:', error);\\n    }\\n  }\\n\\n  getCurrentIndex(): number {\\n    return this.state.currentIndex;\\n  }\\n\\n  setCurrentIndex(index: number): void {\\n    this.state.currentIndex = index;\\n    this.state.lastMessageTime = new Date().toISOString();\\n    this.saveState();\\n  }\\n\\n  incrementIndex(): void {\\n    this.state.currentIndex += 1;\\n    this.state.messageCount += 1;\\n    this.state.lastMessageTime = new Date().toISOString();\\n    this.saveState();\\n  }\\n\\n  resetState(): void {\\n    this.state = { ...DEFAULT_STATE };\\n    this.saveState();\\n  }\\n\\n  getState(): ConversationState {\\n    return { ...this.state };\\n  }\\n\\n  setActive(active: boolean): void {\\n    this.state.isActive = active;\\n    this.saveState();\\n  }\\n\\n  isActive(): boolean {\\n    return this.state.isActive;\\n  }\\n\\n  getMessageCount(): number {\\n    return this.state.messageCount;\\n  }\\n\\n  getLastMessageTime(): string {\\n    return this.state.lastMessageTime;\\n  }\\n}\\n\\n// Export singleton instance\\nexport const stateManager = new StateManager(); \""
                }
              ]
            },
            {
              "name": "twilio",
              "type": "dir",
              "contents": [
                {
                  "name": "twilio-handler.ts",
                  "type": "ts",
                  "contents": "\"import { handleTwilioMessage } from '../../controllers/conversation.controller';\\n\\nasync function main() {\\n  // Get message from command line arguments\\n  const message = process.argv[2];\\n\\n  if (!message) {\\n    console.error('No message provided');\\n    process.exit(1);\\n  }\\n\\n  try {\\n    console.log('[Twilio Handler] Processing message:', message);\\n    console.log('[Twilio Handler] Calling handleTwilioMessage...');\\n    await handleTwilioMessage(message);\\n    console.log('[Twilio Handler] handleTwilioMessage completed successfully');\\n    console.log('[Twilio Handler] Message processed successfully');\\n    process.exit(0);\\n  } catch (error) {\\n    console.error('[Twilio Handler] Error processing message:', error);\\n    process.exit(1);\\n  }\\n}\\n\\nmain().catch(error => {\\n  console.error('[Twilio Handler] Fatal error:', error);\\n  process.exit(1);\\n}); \""
                }
              ]
            }
          ]
        },
        {
          "name": "utilities",
          "type": "dir",
          "contents": [
            {
              "name": "fileLoader.ts",
              "type": "ts",
              "contents": "\"import fs from 'fs';\\n\\nexport function loadJson<T>(filePath: string): T {\\n  try {\\n    const contents = fs.readFileSync(filePath, 'utf8');\\n    return JSON.parse(contents) as T;\\n  } catch (error: any) {\\n    console.error(`[FileLoader] Failed to load JSON from ${filePath}:`, error.message);\\n    throw new Error(`Could not load file at ${filePath}`);\\n  }\\n}\\n\""
            },
            {
              "name": "twilio.ts",
              "type": "ts",
              "contents": "\"import twilio from 'twilio';\\nimport { config } from 'dotenv';\\nimport { SMSMessageParams, TwilioConfig, TwilioServiceResponse, TwilioMessageResponse } from '@models/twilio/twilio.model';\\n\\n// Load environment variables from custom.env\\nconfig({ path: '.env.local' });\\n\\n// Initialize Twilio configuration from environment variables\\nconst twilioConfig: TwilioConfig = {\\n  accountSid: process.env.TWILIO_ACCOUNT_SID!,\\n  authToken: process.env.TWILIO_AUTH_TOKEN!,\\n  botNumber: process.env.BOT_NUMBER!\\n};\\n\\n// Initialize Twilio client\\nconst client = twilio(twilioConfig.accountSid, twilioConfig.authToken);\\n\\n/**\\n * Send SMS text message with minimal parameters\\n * @param to - Recipient phone number (E.164 format recommended: +1234567890)\\n * @param body - Message content (up to 1600 characters)\\n * @returns Promise with success/error response\\n */\\nexport async function sendText(\\n  to: string, \\n  body: string\\n): Promise<TwilioServiceResponse> {\\n  try {\\n    // Validate inputs\\n    if (!to || !body) {\\n      return {\\n        success: false,\\n        error: {\\n          code: 400,\\n          message: 'Missing required parameters: to and body are required',\\n          moreInfo: 'https://www.twilio.com/docs/api/errors',\\n          status: 400\\n        }\\n      };\\n    }\\n\\n    // Prepare message parameters with status callback\\n    const messageParams: SMSMessageParams = {\\n      to,\\n      from: twilioConfig.botNumber,\\n      body,\\n      statusCallback: process.env.STATUS_CALLBACK_URL || 'https://lendex-demo-dev.up.railway.app/twilio/status'\\n    };\\n\\n    console.log('[Twilio] Sending message with callback URL:', messageParams.statusCallback);\\n\\n    // Send the message\\n    const message = await client.messages.create(messageParams);\\n\\n    // Return success response\\n    return {\\n      success: true,\\n      data: {\\n        sid: message.sid,\\n        accountSid: message.accountSid,\\n        from: message.from,\\n        to: message.to,\\n        body: message.body,\\n        status: message.status as any,\\n        direction: message.direction as any,\\n        apiVersion: message.apiVersion,\\n        price: message.price,\\n        priceUnit: message.priceUnit,\\n        errorCode: message.errorCode,\\n        errorMessage: message.errorMessage,\\n        uri: message.uri,\\n        dateCreated: message.dateCreated.toISOString(),\\n        dateSent: message.dateSent?.toISOString() || null,\\n        dateUpdated: message.dateUpdated.toISOString(),\\n        messagingServiceSid: message.messagingServiceSid,\\n        numSegments: message.numSegments,\\n        numMedia: message.numMedia,\\n        subresourceUris: message.subresourceUris\\n      } as TwilioMessageResponse\\n    };\\n\\n  } catch (error: any) {\\n    // Handle Twilio API errors\\n    return {\\n      success: false,\\n      error: {\\n        code: error.code || 500,\\n        message: error.message || 'Unknown error occurred',\\n        moreInfo: error.moreInfo || 'https://www.twilio.com/docs/api/errors',\\n        status: error.status || 500,\\n        details: error.details || {}\\n      }\\n    };\\n  }\\n}\\n\\n/**\\n * Quick send function - even simpler interface for common use cases\\n * @param phoneNumber - Recipient phone number\\n * @param message - Message to send\\n * @returns Promise<boolean> - true if sent successfully, false otherwise\\n */\\nexport async function quickSend(phoneNumber: string, message: string): Promise<boolean> {\\n  const result = await sendText(phoneNumber, message);\\n  return result.success;\\n}\\n\\n/**\\n * Send notification to a lead from your CRM system\\n * @param leadPhoneNumber - Lead's phone number\\n * @param notificationMessage - Notification message\\n * @returns Promise with detailed response\\n */\\nexport async function sendLeadNotification(\\n  leadPhoneNumber: string, \\n  notificationMessage: string\\n): Promise<TwilioServiceResponse> {\\n  return sendText(leadPhoneNumber, notificationMessage);\\n}\\n\""
            }
          ]
        }
      ]
    },
    {
      "name": "test-path-alias.ts",
      "type": "ts",
      "contents": "\"import * as express from 'express';\\n\\nconsole.log('Express imported successfully:', typeof express);\\nconsole.log('Express Router:', typeof express.Router);\\n\\n// Test if we can import from controllers\\ntry {\\n  const { handleDemoTrigger } = require('@controllers/demo.controller');\\n  console.log('Demo controller imported successfully:', typeof handleDemoTrigger);\\n} catch (error: any) {\\n  console.error('Failed to import demo controller:', error.message);\\n} \""
    },
    {
      "name": "tsconfig-paths-bootstrap.js",
      "type": "js",
      "contents": "\"const tsConfigPaths = require('tsconfig-paths');\\n\\n// Load tsconfig.json\\nconst tsConfig = require('./tsconfig.json');\\n\\n// Register path mappings\\ntsConfigPaths.register({\\n  baseUrl: tsConfig.compilerOptions.baseUrl,\\n  paths: tsConfig.compilerOptions.paths,\\n}); \""
    },
    {
      "name": "tsconfig.json",
      "type": "json",
      "contents": "\"{\\n    \\\"compilerOptions\\\": {\\n        \\\"target\\\": \\\"es2018\\\",\\n        \\\"module\\\": \\\"commonjs\\\",\\n        \\\"moduleResolution\\\": \\\"node\\\",\\n        \\\"baseUrl\\\": \\\".\\\",\\n        \\\"paths\\\": {\\n            \\\"@/*\\\":[\\\"src/*\\\"],\\n            \\\"@models/*\\\": [\\\"src/models/*\\\"],\\n            \\\"@services/*\\\": [\\\"src/services/*\\\"],\\n            \\\"@routes/*\\\": [\\\"src/routes/*\\\"],\\n            \\\"@utilities/*\\\": [\\\"src/utilities/*\\\"],\\n            \\\"@controllers/*\\\": [\\\"src/controllers/*\\\"],\\n            \\\"@repositories/*\\\": [\\\"src/repositories/*\\\"]\\n        },\\n        \\\"strict\\\": true,\\n        \\\"esModuleInterop\\\": true,\\n        \\\"skipLibCheck\\\": true,\\n        \\\"forceConsistentCasingInFileNames\\\": true,\\n        \\\"outDir\\\": \\\"./dist\\\",\\n        \\\"rootDir\\\": \\\".\\\",\\n        \\\"resolveJsonModule\\\": true\\n    },\\n    \\\"include\\\": [\\\"src/**/*\\\"],\\n    \\\"exclude\\\": [\\\"node_modules\\\", \\\"testing-scripts/**/*\\\", \\\"code-examples/**/*\\\"]\\n} \""
    }
  ]
}