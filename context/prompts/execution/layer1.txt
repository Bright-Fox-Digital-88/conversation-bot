You are given a single JSON object that is a data dump of a TypeScript/Node.js project’s file tree. It includes file paths, file contents (escaped strings), and types. Your job is to ANALYZE that dump and OUTPUT a single JSON object that linearizes runtime flows for ALL divergent HTTP endpoints and timer-driven paths, TRACKS step-level input state, and—when multiple flows converge into the same standardized logic—APPENDS a compact “common resolution” layer that captures that standardized tail behavior.

IMPORTANT REQUIREMENTS
- Do NOT invent endpoints, inputs, or code paths that are not present in the dump.
- Follow the extraction rules precisely.
- Output MUST be valid JSON matching the schema exactly.
- Use concise, human-readable text derived from actual code.
- Every endpoint/branch you include MUST be supported by code in the dump.
- When multiple flows converge on the same sequence of actions (standardized business logic), summarize that tail once in a dedicated "commonResolution" block (see schema). Do NOT omit branch-specific steps that lead up to it.
- VISUAL FUNCTION FLAGGING: whenever a step CALLS or HANDS OFF to a function whose execution route will be depicted elsewhere in this output (e.g., in later steps, another branch, another flow, or common resolution), you MUST:
  1) wrap the exact function name in double braces inside the human text: e.g., "action": "Call {{handleConversationMessage}} with Body"
  2) include "functionRef": "{{handleConversationMessage}}" in that step (and only on steps that call/hand off)

INPUT FORMAT (what you receive)
- A single JSON document with shape:
  {
    "name": "<root>",
    "type": "dir",
    "contents": [ FileNode | DirNode, ... ]
  }
- File node: { "name": "<filename>", "type": "<ext or 'file'>", "contents": "<escaped source code string>" }
- Directory node: { "name": "<dirname>", "type": "dir", "contents": [ ... ] }

OUTPUT FORMAT (what you must return)
Return exactly one JSON object with this top-level shape:

{
  "executionFlows": [
    {
      "endpoint": "STRING",                        // e.g., "POST /api/conversation" or "timer:conversation-reset"
      "description": "STRING",
      "steps": [
        {
          "step": NUMBER,                          // 1-based within THIS flow
          "actor": "STRING",                       // "Express","Router","Middleware","Controller","Service","Twilio","State","Timer","System"
          "action": "STRING",                      // concise description from code; wrap downstream-depicted functions with {{name}}
          "functionRef": "STRING OPTIONAL",        // if action calls a function depicted later: "{{exactFunctionName}}"
          "logExample": "STRING OPTIONAL",         // short (≤120 chars) real log snippet if available
          "state": {
            "inputs": {                            // values known at this step (only include fields actually read)
              "body": { "field": "value" },
              "query": { "param": "value" },
              "params": { "name": "value" },
              "env": { "VAR_NAME": "value" },
              "headers": { "Header-Name": "value" },
              "timer": { "elapsedMinutes": 25 }
            },
            "changes": {                           // fields modified/set at this step (e.g., state index increment)
              "stateVar": "newValue"
            }
          },
          "branches": [                            // OPTIONAL: only when the code has explicit branching here
            {
              "condition": "STRING",               // e.g., "reset && init", "delivered"
              "steps": [ { ... step objects as above ... } ]
            }
          ]
        }
      ],
      "commonResolution": {                        // OPTIONAL: include when THIS flow converges to a standardized tail
        "appliesWhen": "STRING",                   // e.g., "after any branch that sends via Service"
        "layers": [
          {
            "actor": "STRING",                     // e.g., "Service","Twilio","State","Controller"
            "action": "STRING",                    // generalized tail behavior derived from repeated code paths
            "functionRef": "STRING OPTIONAL",      // use if a layer represents a call that is depicted elsewhere
            "state": {
              "inputs": { ... },                   // minimal inputs common across converged paths
              "changes": { ... }                   // common state mutations (e.g., index++, timestamp)
            },
            "logExample": "STRING OPTIONAL"
          }
        ]
      }
    }
  ],
  "globalCommonResolution": {                      // OPTIONAL: only if ≥2 DISTINCT endpoints share an identical final tail
    "signature": "STRING",                         // short name for the standardized tail, e.g., "Service→Twilio→State success tail"
    "appliesTo": [ "POST /api/…", "POST /api/…" ], // list of endpoints whose tails are identical
    "layers": [
      { "actor": "Service", "action": "Prepare outbound message", "state": { "inputs": {}, "changes": {} } },
      { "actor": "Twilio",  "action": "Send SMS via SDK",         "state": { "inputs": { "body": {}, "env": {} }, "changes": {} } },
      { "actor": "State",   "action": "Persist index/time",        "state": { "inputs": {}, "changes": { "currentIndex": "++", "lastMessageTime": "ISO" } } }
    ]
  }
}

SCHEMA RULES & DEFAULTS
- executionFlows: array, length ≥ 1.
- endpoint: REQUIRED. For HTTP, use "METHOD /path". For timers/background jobs, use "timer:<name>".
- description: REQUIRED (one sentence).
- steps: REQUIRED, non-empty. Each step includes "state" with BOTH "inputs" and "changes" objects (use {} if none).
- branches: OPTIONAL. Only when code shows explicit conditional logic.
- commonResolution (per-flow): OPTIONAL. Include when THIS flow’s branches converge to the same standardized tail sequence.
- globalCommonResolution (cross-flow): OPTIONAL. Include when two or more DISTINCT endpoints share the same tail.
- VISUAL FUNCTION FLAGGING:
  - Only apply when the function’s execution route is (or will be) depicted elsewhere in this output.
  - Wrap the exact function name in double braces within "action".
  - Add "functionRef" with the SAME wrapped token (e.g., "{{sendText}}").
  - Do NOT add "functionRef" if the function is not depicted elsewhere.

EXTRACTION RULES (derive flows + state + common resolution)
1) ROUTES → ENDPOINTS
   - Find Express routers and their mounts. Combine base mount paths with child routes to produce full endpoints.
   - Each endpoint = one executionFlow.

2) CONTROLLERS → INPUTS, BRANCHES, HANDOFF
   - For each route handler, add a Controller step capturing accessed request inputs in state.inputs (body/query/params/headers).
   - Capture env vars read at this step under state.inputs.env.
   - If there’s an if/else or switch, add branches with conditions matching code predicates; within each branch, continue steps linearly.
   - When the controller calls a service function depicted elsewhere, visually flag it: wrap the function in {{ }} in "action" and set "functionRef".

3) SERVICES → CORE ACTIONS + STATE
   - Summarize service actions (send/reset/status/etc.). Include parameters passed in under state.inputs.
   - Record state mutations (e.g., index++, timestamps) under state.changes.
   - When a service calls another function depicted elsewhere (e.g., Twilio sender), apply the visual function flag and "functionRef".

4) TWILIO → SEND + STATE
   - For outbound sends, add a Twilio step with to/body/statusCallback in state.inputs.
   - If responses affect persisted state, reflect that in state.changes.

5) STATE MANAGEMENT → PERSISTENCE
   - When saving to on-disk JSON or equivalent, record new values (index, messageCount, lastMessageTime, isActive) in state.changes.

6) TIMERS/BACKGROUND → STATE
   - Timer start: record timer init in state.changes.
   - Timer tick: set state.inputs.timer.elapsedMinutes.
   - 25/30-minute triggers: include system message text under state.inputs.body and any index reset in state.changes.

7) COMMON RESOLUTION DETECTION (IMPORTANT)
   - After building steps for all branches within a flow, compare the final N steps across branches.
   - If ≥2 branches share an identical tail (same actor/action semantics and same kinds of state changes), extract that tail into "commonResolution" for that flow.
   - After processing all flows, compare tails ACROSS different endpoints. If ≥2 endpoints share the same tail, extract it into "globalCommonResolution".

QUALITY & CONSTRAINTS
- No commentary outside the JSON.
- Do NOT omit the divergent branch steps—common resolution is appended, not a substitute for branching detail.
- Only summarize as "common" when tails are truly identical in behavior.
- Preserve true step order before the common tail.
- Use empty {} for "inputs"/"changes" when not applicable; never omit the "state" object.

VALIDATION PASS (before you output)
- Every flow has endpoint, description, steps (with state), and valid (optional) commonResolution.
- Every "action" that calls a function depicted elsewhere wraps its name in {{ }} and has a matching "functionRef".
- If globalCommonResolution exists, "appliesTo" lists ≥2 endpoints and layers are generic enough to fit all listed flows.
- JSON is syntactically valid.
